# NGINX Load Balancer Configuration for Kronos Hybrid Deployment
# Routes requests between CPU and GPU instances

events {
    worker_connections 1024;
}

http {
    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log warn;

    # Upstream: CPU backend
    upstream kronos_cpu {
        server kronos-api-cpu:8000 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # Upstream: GPU backend
    upstream kronos_gpu {
        server kronos-api-gpu:8000 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # Map to select backend based on request characteristics
    # Default: Use GPU for batch requests, CPU for single requests
    map $request_uri $backend {
        default                     kronos_cpu;
        ~*/v1/predict/batch         kronos_gpu;  # Batch requests -> GPU
    }

    # Alternative: Map based on custom header
    # Client can specify: X-Kronos-Device: gpu or cpu
    map $http_x_kronos_device $backend_override {
        default                     "";
        "gpu"                       kronos_gpu;
        "cpu"                       kronos_cpu;
    }

    server {
        listen 80;
        server_name _;

        # Client request size limits
        client_max_body_size 20M;
        client_body_timeout 300s;

        # Proxy timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;

        # Health check endpoint (routed to CPU for simplicity)
        location /v1/healthz {
            proxy_pass http://kronos_cpu;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Readiness check endpoint (routed to CPU for simplicity)
        location /v1/readyz {
            proxy_pass http://kronos_cpu;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Metrics endpoint (aggregate from both backends)
        location /v1/metrics {
            proxy_pass http://kronos_cpu;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Main API endpoints - smart routing
        location / {
            # Use header override if present, otherwise use URL-based mapping
            set $target_backend $backend;
            if ($backend_override != "") {
                set $target_backend $backend_override;
            }

            proxy_pass http://$target_backend;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Custom headers
            proxy_set_header X-Request-ID $request_id;
            add_header X-Backend-Used $target_backend always;
        }
    }
}
